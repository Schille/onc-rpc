use crate::read_slice_bytes;
use crate::Error;
use byteorder::{BigEndian, ReadBytesExt, WriteBytesExt};
use smallvec::SmallVec;
use std::borrow::Cow;
use std::io::{Cursor, Write};

/// `AuthUnixParams` represents the structures referred to as both `AUTH_UNIX`
/// and `AUTH_SYS` in the various RFCs, used to idenitfy the client as a Unix
/// user.
///
/// The structure is implemented as specified in `APPENDIX A` of
/// [RFC1831](https://tools.ietf.org/html/rfc1831).
///
/// These values are trivial to forge and provide no actual security.
#[derive(Debug, PartialEq)]
pub struct AuthUnixParams<'a> {
    stamp: u32,
    machine_name: &'a str,
    uid: u32,
    gid: u32,

    // Don't store the gids directly, instead synthesise them on demand from the
    // underlying data to avoid allocating for this field when decoding.
    gids: Option<Cow<'a, [u8]>>,
}

impl<'a> AuthUnixParams<'a> {
    /// Initialise a new `AuthUnixParams` instance containing the specified unix
    /// account identifiers.
    pub fn new(
        stamp: u32,
        machine_name: &'a str,
        uid: u32,
        gid: u32,
        gids: Option<&'a [u32]>,
    ) -> Self {
        // Convert the optional slice of gids to wire format
        let gids = gids.map(|v| {
            Cow::from(v.iter().fold(Vec::new(), |mut acc, x| {
                acc.extend(x.to_be_bytes().as_ref());
                acc
            }))
        });

        AuthUnixParams {
            stamp,
            machine_name,
            uid,
            gid,
            gids,
        }
    }

    /// Constructs a new `AuthUnixParams` by parsing the wire format read from
    /// `r`, validating it has read exactly `expected_len` number of bytes.
    ///
    /// `from_cursor` advances the position of `r` to the end of the `AUTH_UNIX`
    /// structure.
    pub(crate) fn from_cursor(r: &mut Cursor<&'a [u8]>, expected_len: u32) -> Result<Self, Error> {
        // Get the start length the parser can validate it read the expected
        // amount of data at the end of the function
        let start_pos = r.position();

        // Read the stamp
        let stamp = r.read_u32::<BigEndian>()?;

        // Read the variable length name
        let name_len = r.read_u32::<BigEndian>()?;
        if name_len > 16 {
            return Err(Error::InvalidAuthData);
        }

        // Read the string without copying
        let name = read_slice_bytes(r, name_len)?;
        let name = std::str::from_utf8(name)?;

        // UID & GID
        let uid = r.read_u32::<BigEndian>()?;
        let gid = r.read_u32::<BigEndian>()?;

        // Gids
        let gids_count = r.read_u32::<BigEndian>()? as usize;
        let gids = match gids_count {
            0 => None,
            v if v <= 16 => {
                let len = gids_count * std::mem::size_of::<u32>();
                Some(Cow::from(read_slice_bytes(r, len as u32)?))
            }
            _ => return Err(Error::InvalidAuthData),
        };

        // Validate the parser read the expected amount of data to construct
        // this type
        if (r.position() - start_pos) != expected_len as u64 {
            return Err(Error::InvalidAuthData);
        }

        Ok(AuthUnixParams {
            stamp,
            machine_name: name,
            uid,
            gid,
            gids,
        })
    }

    /// Serialises this `AuthUnixParams` into `buf`, advancing the cursor
    /// position by [`serialised_len`](AuthUnixParams::serialised_len) bytes.
    pub fn serialise_into(&self, buf: &mut Cursor<Vec<u8>>) -> Result<(), std::io::Error> {
        buf.write_u32::<BigEndian>(self.stamp)?;
        buf.write_u32::<BigEndian>(self.machine_name.len() as u32)?;
        buf.write_all(self.machine_name.as_bytes())?;
        buf.write_u32::<BigEndian>(self.uid)?;
        buf.write_u32::<BigEndian>(self.gid)?;
        buf.write_u32::<BigEndian>(
            self.gids
                .as_ref()
                .map_or(0, |v| (v.len() / std::mem::size_of::<u32>()) as u32),
        )?;
        match self.gids.as_ref() {
            Some(d) => buf.write_all(d.as_ref()),
            None => Ok(()),
        }
    }

    /// An arbitrary ID generated by the caller.
    pub fn stamp(&self) -> u32 {
        self.stamp
    }

    /// The hostname of the caller's machine.
    pub fn machine_name(&self) -> &str {
        self.machine_name
    }

    /// The caller's Unix user ID.
    pub fn uid(&self) -> u32 {
        self.uid
    }

    /// The caller's primary Unix group ID.
    pub fn gid(&self) -> u32 {
        self.gid
    }

    /// Returns a copy of the `gids` array, a set of Unix group IDs the caller
    /// is a member of.
    ///
    /// This value is synthesised on demand by converting the big endian wire
    /// values into u32's, and is specified to contain at most 16 values.
    pub fn gids(&self) -> Option<SmallVec<[u32; 16]>> {
        let raw = self.gids.as_ref()?;

        // Figure out how many values to read
        let have = raw.len() / std::mem::size_of::<u32>();
        debug_assert!(have > 0);

        let mut c = Cursor::new(raw);
        let mut v = SmallVec::<[u32; 16]>::new();
        for _ in 0..have {
            v.push(
                c.read_u32::<BigEndian>()
                    .expect("failed to read gid from buffer"),
            );
        }

        Some(v)
    }

    /// Returns the on-wire length of this message once serialised, including
    /// the message header.
    pub fn serialised_len(&self) -> u32 {
        // uid, gid, stamp
        let mut l = std::mem::size_of::<u32>() * 3;

        // machine_name length u32 + bytes
        l += std::mem::size_of::<u32>() + self.machine_name.len();

        // gids array + length u32
        l += std::mem::size_of::<u32>()
            + match &self.gids {
                Some(v) => v.len(),
                None => 0,
            };

        l as u32
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use hex_literal::hex;
    use smallvec::smallvec;

    #[test]
    fn test_serialise_deserialise() {
        let gids = vec![
            501, 12, 20, 61, 79, 80, 81, 98, 701, 33, 100, 204, 250, 395, 398, 399,
        ];
        let p = AuthUnixParams::new(0, "", 501, 20, Some(&gids));

        let mut buf = Cursor::new(Vec::new());
        p.serialise_into(&mut buf).expect("failed to serialise");

        // Known good wire value trimmed of flavor + length bytes.
        //
        // Credentials
        //     Flavor: AUTH_UNIX (1)
        //     Length: 84
        //     Stamp: 0x00000000
        //     Machine Name: <EMPTY>
        //         length: 0
        //         contents: <EMPTY>
        //     UID: 501
        //     GID: 20
        //     Auxiliary GIDs (16) [501, 12, 20, 61, 79, 80, 81, 98, 701, 33, 100, 204, 250, 395, 398, 399]
        //         GID: 501
        //         GID: 12
        //         GID: 20
        //         GID: 61
        //         GID: 79
        //         GID: 80
        //         GID: 81
        //         GID: 98
        //         GID: 701
        //         GID: 33
        //         GID: 100
        //         GID: 204
        //         GID: 250
        //         GID: 395
        //         GID: 398
        //         GID: 399
        //
        let want = hex!(
            "0000000000000000000001f50000001400000010000001f50000000c0000001400
            00003d0000004f000000500000005100000062000002bd000000210000006400000
            0cc000000fa0000018b0000018e0000018f"
        );

        let buf = buf.into_inner();
        assert_eq!(want.len(), buf.len());
        assert_eq!(want.as_ref(), buf.as_slice());

        let mut c = Cursor::new(want.as_ref());
        let s = AuthUnixParams::from_cursor(&mut c, 84).expect("deserialise failed");

        assert_eq!(p, s);
    }

    #[test]
    fn test_empty() {
        // Known good wire value trimmed of flavor + length bytes.
        //
        // Credentials
        //     Flavor: AUTH_UNIX (1)
        //     Length: 24
        //     Stamp: 0x00000000
        //     Machine Name: <EMPTY>
        //         length: 0
        //         contents: <EMPTY>
        //     UID: 0
        //     GID: 0
        //     Auxiliary GIDs (1) [0]
        //         GID: 0
        let want = hex!("000000000000000000000000000000000000000100000000");
        let mut c = Cursor::new(want.as_ref());

        let s = AuthUnixParams::from_cursor(&mut c, 24).expect("deserialise failed");

        assert_eq!(s.stamp(), 0);
        assert_eq!(s.machine_name(), "");
        assert_eq!(s.uid(), 0);
        assert_eq!(s.gid(), 0);
        assert_eq!(s.gids(), Some(smallvec![0]));
        assert_eq!(s.serialised_len(), 24);

        let mut buf = Cursor::new(Vec::new());
        s.serialise_into(&mut buf).expect("failed to serialise");

        let buf = buf.into_inner();
        assert_eq!(want.len(), buf.len());
        assert_eq!(want.as_ref(), buf.as_slice());
    }
}
